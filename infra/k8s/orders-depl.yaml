apiVersion: apps/v1 #version de api
kind: Deployment #tipo de archivo
metadata:
  name: orders-depl #como un nombre
spec:
  replicas: 1 #indicamos una replica en ejecucion (un pod)
  selector:
    matchLabels: # Seleccionara el template de abajo
      app: orders
  template:
    metadata:
      labels: #para el matchLabel
        app: orders
    spec:
      containers:
        - name: orders #nombre del contenedeor (no es usado x el matchlabel
          image: gustavocondezo/orders
          env: #AÃ±adir variables de entorno a estos pods
            - name: MONGO_URI #variable con valor definido
              value: 'mongodb://orders-mongo-srv:27017/orders'
            - name: JWT_KEY #variable cuyo valor sera extraido de kubernetes secrets
              valueFrom: #Origen le decimos que los extraiga de kubernetes secrets
                secretKeyRef:
                  name: jwt-secret
                  key: JWT_KEY
            - name: KAFKA_URL
              value: 'kafka-srv:9092'
            - name: KAFKA_CLIENT_ID #Toma el valor unico por intancia proporcionado por kubenetes
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
---

apiVersion: v1
kind: Service # tipo de archivo
metadata:
  name: orders-srv
spec:
  selector: #selecciona los pods con label orders
    app: orders
  type: ClusterIP #Si no se pone sera x defecto ClusterIP
  #ClusterIP PERMITE QUE SE CONECTEN ENTRE PODS (interna)
  #NodePort permite que el puerto este disponible fuera (externa)
  ports:
    - name: orders
      protocol: TCP
      port: 3000 # El Node Port Service abre este puerto (al exterior) y luego redirige hacia el targetPort. (pueden ser diferentes)
      targetPort: 3000 # puerto donde nuestra app escucha (dentro del contenedor)
# adicionalmente se creara un puerto externo aleatorio con ip (localhost) desde donde sera accesible el pod desde el exterior
